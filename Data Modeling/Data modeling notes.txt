What is Requirements in Data modeling?
it refer to the detailed understanding and documentation of what data an organization need to store, process and retrieve.

store, process and retrieve build your foundation.

Real life case: 
cooking: 
	- understand the recipe
	- no of serving
	- dietary restrictions.
	- tools

stockholders > domain experts
- what data do they need to store?
- what data should be process or analyzed? 
- What question should the data answer?
- what the rules that the data must follow?
- are there any constraints like privacy or access limitations?

once you get answers create the blueprint(data model). which help you to organize the data and access it easily.

Why Gather requirements in Data modeling?
- to build a data model that accurately represents bussing needs.
- to avoid wasted effort and resources.
- DB decision making effectively. 

Benefits of proper Gather requirements?
- cost effectiveness
- Accuracy
- Efficiency
- better data quality
- Clarity.

When to use the Gather requirements in Data Modeling?
- at the start of any Data modeling project.
- building new DB or system.
- improve existing DB system.
- migrating data between systems.
- system upgrade due to new requiems. 

Real Live Case:
retail company create db to track sales
- interview sales manager
- inventory team
- finance staff. 
	cust detail, product info, sales transection, discount and promotion rules.

report sales, inventory manage, revenue analysis without any complexity.


when not to use or limitations
- very small or simple data task 
- data change rapidly (agile iterative approach might be best)
- stakeholders have lack of domain knowledge.
- without clear objective cost heigh.


Disadvantage/ challenges Gather requirements
- Time consuming
- Miscommunication of risks
- Incomplete requirement
- Changing requirements.
- Dependency on stakeholders 

----------------------------------------
Class 2
Methodologies
Parts of methodologies
- conceptual, logical, physical data modeling
- hierarchical data modeling
- network data modeling
- Relational data modeling
- Object oriented data modeling
- Entity-Relationship (ER) Model
- Dimensional data modeling
- Graph data modeling

- Conceptual, Logical, Physical data modeling
these represent level based approach to Data modeling. serves as the foundation for all methodologies.

Conceptual Model: it shows you the big picture which describes the overall structure main entities of data without technical details. used in discussion b/w stakeholders and data architects to under the requirements.

	Logical model: Adds details such as
		attributes
		relationships 
		rules
	without tying the design to particular DB structure.
	used to clarify structure and relationships.

	Physical model: it is a format for implementing on a specific DB system, taking into account, like indexes and performance optimization.

- Hierarchical Data Modeling: Data arranges in a tree like structure: every parent node can have multiple child nodes, but every child can only have one parent.

	Benefits:
		- Simple to understand
		- fast for hierarchical, repetitive data

	real life case:
		company structure: CEO -> department head -> team lead -> Employee 

	when/why to use:
		- best for fixed, hierarchical  data - employee management.

	Disadvantages/ when not to use:
		- complex relationship (when multiple parents are needed)
		- data change frequently. or difficult to reorganize or accommodate changes.


- Network Data Modeling: it allows children to have multiple parents.
Data organized like a graph or nodes and links.

	Benefits: 
		- flexible for complex relationship.
		- efficient for Many-to-many

	when/why to use:
		- when relationship is complex.(eg. transportation network, project management dependencies)

	Disadvantages/ when not to use:
		- very difficult to design and manage


- Relational data modeling: it is tales(relations) where each table row is a record and each column is an attribute. 
Relationship b/w tables are managed using keys.

	When/why to use:
		when data needs to be normalized and diff data types are closely related(banking, retail, HR).


	real life case:
		banking application: Accounts, customers, Transactions - 
all connected by keys.

	Disadvantages / when not to use:
		- May be overkill for very small or unstructured data.
		- joins can be slow with huge dataset, scaling can be complex.


- Object-Oriented Data Model: it contains attributes(data) and behaviors(methods). same as oops programming.

	Benefits: 
		- Works well with complex data and relationship.
		- supports inheritance and encapsulation.

	when/why to use:
		application working closely with object-oriented programming like CAD system or multimedia db.

	real life case:
		multimedia system management (images, videos, audio)

	Disadvantages/when not to use: 
		- not supported with traditional relational DB.
		- can be complex.
		- Costly

----------------------------------------
Class 3
What is Entity-Relational (ER) data model: Visuslization data as "entity" (things) are "relationship" (how those thing interact.)

	how does it work?
		- diagrams with shapes
			- rectanges (entities)
			- ovals (attribute)
			- diamonds (relationships)
	
	Benefits:
		- creates a shared language for business and IT.
		- Simplifies complex systems visually.
	
	when to use:
		- during DB design, especially before setting us relational schema.
		- teaching and communication for complex data system.
	
	real life case:
		- university: 
			entities: student, class, professor
			relationship: "enrolled in", "teachers"
		
	Disadvantages / when not to use
		- can become messy with large, higly connected system.
		- Needs conversion before implementation.
		
	
- Dimensional Data Model: organize data around "fact" (achtions or number measured -like sales, profit) and dimensinas (context - like time, location, product...)
	
	how does it work?
		Star or snowflake schemas provide easy, fast acess to maetrics for analytics and reporting.
	
	Benifits:
		- highly performant for reporting
		- simple queries for end users - "how may blue shirts sold in july?"
	
	When to use:
		- data warehouse
		- bi reporting
		- historical trend tracking
		
	Why to use:
		- self-service analysis.
		- speed for summary data.
	
	real life case:
		sales dashboard: facts(Sales amount) and dimensions(store, time, product line)
	

- Graph Data model: represent data as graph of nodes (entities) and edges (relationship)
	

----------

Data modeling life cycle
- Requirements analysis : as same as above
	real life case:
		you interview the sales tieam and gind that they need to track
			- sales by product
			- customers
			- timings
			- stores
			- regions
			- profit margin
			- turnover
			
- Conceptual data model: it contains only entities
	real life case:
		mapping our hospial main enitity
			- Patients
			- Doctors
			- Appointments
			- treatments
				(and how they connect.)
	
- Logical data modeling: plateform indepent blueprint. 
	real life case:
		university system:
			- student(studnetID, name, email)
			- course(CourseID, Name, Credits)
			- Enrollment(EnrollmentID, StudnetID, CourseID, Team)
		
- Physical data modeling: selection of datatype, set up constaints, indexes, secuurity, sometimes we have to deside the hardware.
	real life case:
		encrypting the sensitive data
		
- Tesing, validating & refinemnet: test for accuracy, preformance, refine as needed.

- Deployment: moving the tested model to production environment.

- Mainenance & optimization: bug fix, review, secuurity, fine-tune, onging updates. (it is always an ongoing process).

----------------------------------------
Class 4
ER-Diagram: Entity-Relationship diagram(ERD):  Visual representation of major entities (object) in db.
- structure logic
- relationship

ERDs standardized symboles:
- rectanges: entities
- ovals: attributes
- diamonds: relationship

example:- School db
	- entites: Main objects- Student, Class, Teacher
	- Attribute: Details about each entity: Studnet name, age; class name, time; teacher name, subject.
	- relationship: How entites connect- studnet enroll in class, teachs teach the class.
	

entity:
	- strong
	- weak

attribute
	- key
	- composit
	- multivalued
	- derived

Relationship
	- one to one
	- one to many
	- many to one
	- many to many

benifits: 
	- clarity
	- communication
	- planning
	- conversion
	- Error checking

real life case:
	er diagram for patient, doctor, test.
	- patient: id, name, insurance, admission date.
	- doctor: id, name, specialization.
	- test: test id, result, data.

	relationship
		- a doctor can treat may patients(one to many)
		- patient may undergo many test; a test canblong to several patients (many to many)
		
Disadvantages/when not:
	- Loss of details
	- Mondification difficult
	- scalability  issues
	- No standards
	
ER-diagram of university system
	- students: Stud_id (pk), name, DOB
	- course: course_id (pk), course_name, credits.
	- proferssor: pro_id(pk), name, title

relationship
	- studnet enrols in course(many to many)
	- course taught by proferssor

studnets --< enrols >-- couses --< taught_by >-- proferssor

-----------------------------------
Class 5
Types of entities
	- strong: 
		- represented as rectange in ER diagram.
		- it has primary key that ensures its unique data.
		- it is type of entity that has a key attribute that can uniquely identify each entity
	- weak: 
		- it is associated with the storng entity with its identification.
		- when we tell the realtionship b/w strong and week entity then it will in double dimonds

attribute
	- key: it holdes the unique values (PK)
	- composit: made up of smaller sub attributes
		address is broken down into: hno, street, city, zip,
	- multivalued: it can have more thena on value for a single entity. 
		- person can have more then one numbers.
		- a person can speak multiple languages.
		- a person can have multiple skills
		- a person can hold multiple degrees
	- derived: not stored directly. its value is calculated from other data.
		- age --- derived from --- DOB
			2025-1998 = 27
		- grade can be derived from percentage
		- total salary derived from hr+bonus+basic
		- Employee Tenure can be derived from hiring date.

key: under line
Composit Attribute: ovel
Multi-values: doulbe ovel
derived: dashed ovel

Relationship:- 
- One to one
- One to many
- Many to one
- Many to many

One to one: single instance of an enity is associated with a single instance of another entity.
	- person has 1 passport no.
	- studnet and id

One to many: singe enstance of an entity is associated with more than one instances. 
	- one dept has many employee
	- customer can place may orders
	- company has many requirement
	
Many to one: more than one instances of an entiy is associatd iwth asingle instance of anoter enity.
	- many students got to one college
	- one country can have many states
	- many employee has one company

Many to many: when one instance of on entity is associatedd with more than one instances of anoter entity.
	- many studnets assisgned project
	- many people can play many games
	

-------------------------
class 6
Degree:
	it reffers to the number of distinct enititys type that participate in a relatinonship. 

types of Relationship degrees:
	- Unary (Degree 1): One entity set relates to itself - a self relationship
		Example: 
			- Employee supervises employee
			- Person is a mentor to person.
		Benifits: recursive relations with a single group.
		

	- Binary (Degree 2):Connects two distinct entity type. (Most common)
		example: 
			- Customer and order
			- Teacher and studnet
		benifits: simple, easy to represent, and easy to implement in DB.
		
		
	- Ternary (Degree 3): involves three entity types in a one relatinonship.
		example: 
			- doctor prescribe medicine to patient.
			- supplier supplies product to store.


	- n-ary (Degree n): Four or more entity participate in a relationship.
		Example: 
			- teacher teaches course in room at time
		
		Benifits: covers highly complex bussiness scenarios in on relationship.

Benifits of Degree
	- clarifies system complexity.
	- Guides table Design.
	- improves communication.
	
when not use:
	- too simple for complex logics: degree 3 / degree n can be hard to implement.
	- hard to maintenace
	- performance issus.
	

d1 - [employee] ---- supervises -----> [employee]

d2 - [customer] ---- place -----> [order]
	
			[Doctor]
		/
		|
d3 - patient 	---- prescribes ----> [medicine]
		|
		\
			[Data]


			[Teacher]
			   \
				\
d4 - [course] ----- teachers ---- [room]
				/
			   /
			[Time]

-------------------------
class 7
What is Cardinality?
	in human language cardinality descibes the numerical relationship b/w 2 entities (table).
	
	how many instances of entity A can be associated with how many instance of entity B.
	
Rules:
	- can  one customer have only one order, or many order?
	- can one student be enrolled in only one couse or many course?
	- can on produt belongs to only on category or many?
	
- One-to-One (1:1): one recored in entity A can be associated with only one record in entity B and vice versa.
	real life example:
		- Person and passport
		- User andd userProfile
		- Country and capital city
		- employee and laptop
		
	when to use:
		- security
		- performance
	
[person] --- (1:1) ---- [passport]

- One-to-Many (1:M) / Many-to-One (M:1): most commont relatinonship. 
	real life example:
		- customer and order
		- Department and employees

[customer] ------ (1:M) ----- [order]
	
	when to use:
		- whe you have to connect with multiple entities


- Many-to-Many (M:N): many record of A entites and many record of B entites.
	real life example:
		- studnet and course
		- Products and orders
		- Authors and books

[Studnet] ------ (M:N) -------- [Course]

Benifits of cardinality?
	- Data integrity
	- Clear Business Rules
	- DB performance
	- Blueprint For developer

Disadvantages
	- Incorrect cardinality
	- Overusing of 1:1 relatinonship

1:1 , 1:M, M:N
entire table FK, fk will be in Order table, require the junction table (can not be done directly)

----
Normalization?
	is the process of organizing data in a database to reduce the redudancy (duplication) and improve the data integrity.

The Normal Forms (NFs): normalization is done in stages called as Normal Forms (NF)

1. First Normal Form (1NF) - the foundataion.
	- Atomic values: Each column contas only single, individual values
	- unique rows: PK
	- column consistency: all data must of same type

	befor normalization:
		OrderId		Customer		Products
		101			Humera			Laptop, Mouse
		102			Hemant			Laptop, mobile, headpone
	
	after normalization (1NF):
		table Order:
			OrderId 	Customer
			101			Humera
			102			Hemant
		
		table OrderDetail:
			detailID 	OrderID 		Products
			1			101				Laptop
			2			101				Mouse
			3 			102				Laptop
			4			102				mobile
			5 			102				headpone


2. Second Normal Form (2NF) - Remove Partial Dependency
	Prerequits: the table must already be in 1NF
	
Before 2NF
OrderID		ProductID		ProductName		CustName	Qty
101			P500			Laptop			Humera		1
101			P600			Mouse			Humera		1

After Normalization
	table: orders
		OrderID 		CustName
		101				Humera
		
	table: OrderDetail (now in 2NF)
		OrderID		ProductID	Qty
		101			P500		1
		101			P600		1

	Table: Products (New table for anoter dependency)
		ProductID 	ProductName
		P500		Laptop
		P600		Mouse


Third Normal Form (3NF)	- Remove Transitive Dependency
	Prerequits: the table must already be in 2NF
	
Before 3NF
	Students
		StdID 	StdName		ZipCode 	City	State
		S1		Ramesh		100001		delhi	ND
		S2		Suresh		200101		pune	MH
		S3		Mahesh		124001		rohtak	HR

After Normalization
	zipcode
		zipcode		city	State
		100001		delhi	ND
		200101		pune	MH
		124001		rohtak	HR
		
	Students
		StdID		StdName		ZipCode
		S1			Ramesh		100001
		S2			Suresh		200101
		S3			Mahesh		124001
		

-------------------------
class 8
Converging from E-R - diagram

Rules of converting components of an ER-Diagram
	- Converting Entities (Easies part)
		- rule: Each regular entity becomes table
		- How to: the attribute of an entity become the columns of the talbe . the Primary Key (Underline in ER-Diagram) become your primary key.
		
		eg: Customer entity with attributes custerID(PK), name, email.
		
		create talbe customer(
			custerID Int primary key,
			name varchar(100)
			email varchar(255)
		);
	
	- Converting Relationship(the core process).
		- One-to-Many(1:M) 
			eg: Department has many employee
				
			create talbe Department(
				dept_id int Primary key,
				dept_name varchar(100)
			)
				
			create table Employee(
				emp_id int Primary Key,
				emp_name varchar(100),
				dep_id int, -- Foreign key added to many side
				Foreign key (dep_id) references Department(dept_id)
	
	- Many-to-Many (M:N) Relationship
		eg: student can enroll in may couses and a course can have many students.
		
		create talbe Student(
			std_id int Primary Key,
			std_name varchar(100)
		)
		create talbe Couse(
			course_id int Primary Key,
			couse_title varchar(100)
		)
		---the junction table
		
		create table Enrollment(
			std_id int,
			course_id int,
			enroll_date Date, --- this can hold attribute about the relationship itself
			Primary Key (std_id, course_id) -- composit primary key
			Foreign key (std_id) references student(std_id),
			Foreign key (course_id) references student(couse_id),
		)
		
- One-to-One (1:1)
	rule:- 
		- add a foreign key to one of the table and make it Unique
		- Merge the 2 entites into a single table.
		
	eg: a user and one profile
		
		create table User(
			user_id int primary key
			username varchar(50)
			password varchar(255)			
		)
		create table Profile(
			p_id int primary key,
			full_name varchar(100),
			bio text,
			user_id int unique
			foreign key (user_id) references User(user_id)
		)

benifits
	- Systematic and error-free design
	- Blueprint for implementation
	- clear communication
		
		